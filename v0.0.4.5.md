# v0.0.4.5 版本规划：多笔记本支持

## 功能概述

在现有的单笔记本基础上，增加多笔记本并发运行支持，实现笔记本的标签页管理，提供更好的多任务处理能力。

## 技术架构

### 后端架构
1. NotebookManager：笔记本管理器
2. NotebookInstance：笔记本实例
3. CodeExecutionContext：代码执行上下文
4. DataFrameRegistry：DataFrame注册表

### 前端架构
1. NotebookTabs：笔记本标签页组件
2. NotebookEditor：笔记本编辑器组件
3. NotebookStore：笔记本状态管理
4. WebSocket通信：实时状态同步

## 详细实现步骤

### 第一阶段：后端基础架构（预计2天）

#### 1.1 创建基础类结构（0.5天）

在这个阶段，我们需要创建支持多笔记本并发运行的核心类结构。每个类都有其特定的职责和作用：

1. NotebookManager 类的设计考虑：
   - 使用异步锁（asyncio.Lock）确保并发操作的安全性
   - 实现笔记本实例的生命周期管理
   - 通过字典存储活动的笔记本实例
   - 设置最大并发数量限制，防止资源过度使用
   - 提供笔记本的创建、获取、删除等基本操作

2. NotebookInstance 类的设计考虑：
   - 封装单个笔记本的所有状态和行为
   - 维护笔记本的执行环境和变量空间
   - 管理笔记本的生命周期状态
   - 实现代码执行的并发控制
   - 记录笔记本的活动状态和时间戳

3. CodeExecutionContext 类的设计考虑：
   - 提供独立的代码执行环境
   - 管理全局和局部变量空间
   - 配置matplotlib和plotly等可视化环境
   - 处理代码执行的输入输出
   - 实现错误捕获和处理机制

4. DataFrameRegistry 类的设计考虑：
   - 管理笔记本中的DataFrame对象
   - 实现线程安全的数据访问
   - 提供DataFrame的注册和检索功能
   - 优化内存使用和性能

##### NotebookManager 类实现
```python
class NotebookManager:
    def __init__(self):
        self._notebooks: Dict[str, NotebookInstance] = {}
        self._lock = asyncio.Lock()
        self._max_notebooks = 10  # 最大并发笔记本数量
        
    async def create_notebook(self, notebook_id: str) -> NotebookInstance:
        async with self._lock:
            if len(self._notebooks) >= self._max_notebooks:
                raise ValueError("达到最大笔记本数量限制")
            notebook = NotebookInstance(notebook_id)
            self._notebooks[notebook_id] = notebook
            return notebook
            
    async def get_notebook(self, notebook_id: str) -> NotebookInstance:
        async with self._lock:
            if notebook_id not in self._notebooks:
                raise ValueError(f"笔记本 {notebook_id} 不存在")
            return self._notebooks[notebook_id]
```

##### NotebookInstance 类实现
```python
class NotebookInstance:
    def __init__(self, notebook_id: str):
        self.notebook_id = notebook_id
        self.execution_context = CodeExecutionContext()
        self.dataframe_registry = DataFrameRegistry()
        self.status = "idle"
        self.last_activity = datetime.now()
        self.execution_count = 0
        self._lock = asyncio.Lock()
        
    async def execute_code(self, code: str) -> Dict[str, Any]:
        async with self._lock:
            self.status = "running"
            try:
                result = await self.execution_context.execute(
                    code, 
                    self.dataframe_registry
                )
                return result
            finally:
                self.status = "idle"
                self.last_activity = datetime.now()
```

##### CodeExecutionContext 类实现
```python
class CodeExecutionContext:
    def __init__(self):
        self.globals_dict = self._initialize_globals()
        self.locals_dict = {}
        self._configure_matplotlib()
        self._configure_plotly()
        
    def _initialize_globals(self) -> Dict[str, Any]:
        globals_dict = {
            '__name__': '__main__',
            'np': np,
            'pd': pd,
            'plt': plt,
            'px': px,
            'go': go
        }
        return globals_dict
        
    async def execute(
        self, 
        code: str, 
        dataframe_registry: DataFrameRegistry
    ) -> Dict[str, Any]:
        # 实现代码执行逻辑
        pass
```

##### DataFrameRegistry 类实现
```python
class DataFrameRegistry:
    def __init__(self):
        self._dataframes: Dict[str, pd.DataFrame] = {}
        self._lock = threading.Lock()
        
    def register_dataframe(self, name: str, df: pd.DataFrame):
        with self._lock:
            self._dataframes[name] = df
            
    def get_dataframe(self, name: str) -> Optional[pd.DataFrame]:
        with self._lock:
            return self._dataframes.get(name)
```

#### 1.2 实现笔记本管理器（0.5天）

笔记本管理器的实现需要考虑以下关键点：

1. 笔记本创建功能：
   - 使用UUID生成唯一标识符
   - 实现依赖注入模式获取管理器实例
   - 添加错误处理和状态验证
   - 返回标准化的API响应

2. 并发控制机制：
   - 使用异步队列管理代码执行请求
   - 实现最大并发执行数量限制
   - 提供任务调度和优先级管理
   - 处理执行超时和中断

3. 资源管理：
   - 监控系统资源使用情况
   - 实现自动清理机制
   - 处理异常情况下的资源释放
   - 提供资源使用统计

##### 笔记本创建功能
```python
@router.post("/notebooks")
async def create_notebook(
    request: Request,
    notebook_manager: NotebookManager = Depends(get_notebook_manager)
):
    notebook_id = str(uuid.uuid4())
    try:
        notebook = await notebook_manager.create_notebook(notebook_id)
        return {
            "notebook_id": notebook_id,
            "status": "created"
        }
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

##### 并发控制机制
```python
class NotebookExecutionQueue:
    def __init__(self):
        self._queue = asyncio.Queue()
        self._running = set()
        self._max_concurrent = 3
        
    async def add_execution(
        self, 
        notebook_id: str, 
        code: str
    ):
        await self._queue.put((notebook_id, code))
        if len(self._running) < self._max_concurrent:
            asyncio.create_task(self._process_queue())
```

#### 1.3 实现笔记本实例（0.5天）

笔记本实例的实现需要关注以下方面：

1. 代码执行环境隔离：
   - 创建独立的Python解释器环境
   - 管理包导入和模块加载
   - 实现变量空间隔离
   - 控制可用模块和函数范围

2. 变量空间管理：
   - 跟踪变量的创建和修改
   - 维护变量的历史记录
   - 提供变量的序列化和持久化
   - 实现变量的作用域控制

3. 执行状态管理：
   - 记录代码执行的状态变化
   - 提供状态查询和通知机制
   - 处理异常状态的恢复
   - 实现状态持久化

##### 代码执行环境隔离
```python
class IsolatedEnvironment:
    def __init__(self):
        self.globals_dict = {}
        self.locals_dict = {}
        self._setup_environment()
        
    def _setup_environment(self):
        # 设置基础环境
        self.globals_dict.update({
            '__builtins__': __builtins__,
            '__name__': '__main__',
            '__doc__': None,
        })
        
        # 导入常用包
        for module_name, alias in ALLOWED_IMPORTS.items():
            try:
                module = importlib.import_module(module_name)
                self.globals_dict[alias] = module
            except ImportError:
                pass
```

##### 变量空间管理
```python
class VariableManager:
    def __init__(self):
        self._variables = {}
        self._history = []
        
    def set_variable(self, name: str, value: Any):
        self._variables[name] = value
        self._history.append({
            'action': 'set',
            'name': name,
            'timestamp': datetime.now()
        })
        
    def get_variable(self, name: str) -> Optional[Any]:
        return self._variables.get(name)
```

#### 1.4 实现代码执行上下文（0.5天）

代码执行上下文的实现需要考虑：

1. 代码执行功能：
   - 捕获标准输出和错误输出
   - 处理代码执行异常
   - 提供执行结果格式化
   - 支持异步执行模式

2. 输出处理：
   - 实现输出流重定向
   - 处理不同类型的输出内容
   - 提供输出限制和截断
   - 支持富文本输出格式

3. 安全控制：
   - 限制危险操作和系统调用
   - 实现代码执行超时控制
   - 提供资源使用限制
   - 防止恶意代码执行

##### 代码执行功能
```python
class CodeExecutor:
    def __init__(self):
        self.output_buffer = io.StringIO()
        self.error_buffer = io.StringIO()
        
    async def execute_code(
        self, 
        code: str, 
        globals_dict: dict, 
        locals_dict: dict
    ) -> ExecutionResult:
        with redirect_stdout(self.output_buffer), \
             redirect_stderr(self.error_buffer):
            try:
                exec(code, globals_dict, locals_dict)
                output = self.output_buffer.getvalue()
                return ExecutionResult(
                    status="success",
                    output=output
                )
            except Exception as e:
                error = self.error_buffer.getvalue()
                return ExecutionResult(
                    status="error",
                    error=str(e),
                    traceback=error
                )
```

### 第二阶段：前端基础架构（预计2天）

#### 2.1 创建标签页组件（0.5天）

标签页组件的实现需要考虑：

1. 用户界面设计：
   - 实现直观的标签页布局
   - 提供清晰的状态指示
   - 支持标签页的关闭和切换
   - 优化视觉效果和交互体验

2. 状态管理：
   - 跟踪活动标签页
   - 管理标签页的生命周期
   - 处理标签页的状态变化
   - 实现状态持久化

3. 事件处理：
   - 响应用户交互事件
   - 处理标签页的打开和关闭
   - 实现标签页的切换逻辑
   - 提供快捷键支持

##### NotebookTabs.vue 组件
```vue
<template>
  <div class="notebook-tabs">
    <el-tabs
      v-model="activeTab"
      type="card"
      closable
      @tab-click="handleTabClick"
      @tab-remove="handleTabRemove"
    >
      <el-tab-pane
        v-for="tab in openedNotebooks"
        :key="tab.id"
        :name="tab.id"
      >
        <template #label>
          <div class="tab-label">
            <span class="notebook-name">{{ tab.name }}</span>
            <el-tag 
              v-if="tab.status === 'running'"
              size="small"
              type="info"
            >
              运行中
            </el-tag>
          </div>
        </template>
      </el-tab-pane>
    </el-tabs>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useNotebookStore } from '@/stores/notebook'

const notebookStore = useNotebookStore()
const activeTab = ref('')

// 获取打开的笔记本列表
const openedNotebooks = computed(() => notebookStore.openedNotebooks)

// 处理标签页点击
const handleTabClick = (tab) => {
  notebookStore.setActiveNotebook(tab.name)
}

// 处理标签页关闭
const handleTabRemove = async (tabName) => {
  await notebookStore.closeNotebook(tabName)
}
</script>

<style scoped lang="scss">
.notebook-tabs {
  border-bottom: 1px solid var(--el-border-color);
  padding: 4px 8px;
  
  .tab-label {
    display: flex;
    align-items: center;
    gap: 8px;
  }
}
</style>
```

#### 2.2 更新编辑器组件（0.5天）

编辑器组件的改造需要考虑以下几个方面：

1. 多笔记本支持：
   - 实现编辑器实例的动态创建和销毁
   - 管理每个笔记本的编辑器状态
   - 保持编辑器内容的同步
   - 处理笔记本切换时的状态保存和恢复

2. 代码执行集成：
   - 实现代码单元格的执行控制
   - 显示执行状态和进度
   - 处理执行结果的展示
   - 支持执行队列管理

3. 用户交互优化：
   - 提供直观的工具栏操作
   - 实现代码补全和语法提示
   - 支持快捷键操作
   - 优化输出结果的展示

##### NotebookEditor.vue 组件改造
```vue
<template>
  <div class="notebook-editor">
    <div class="editor-toolbar">
      <el-button-group>
        <el-button 
          @click="runCell"
          :loading="isRunning"
        >
          运行
        </el-button>
        <el-button @click="addCell">
          添加单元格
        </el-button>
      </el-button-group>
    </div>
    
    <div class="cells-container">
      <template v-for="cell in cells" :key="cell.id">
        <div 
          class="cell"
          :class="{ 'is-active': cell.id === activeCell }"
        >
          <MonacoEditor
            v-model="cell.content"
            language="python"
            :options="editorOptions"
            @change="handleCodeChange(cell.id)"
          />
          <div 
            v-if="cell.output"
            class="cell-output"
          >
            <OutputDisplay :data="cell.output" />
          </div>
        </div>
      </template>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useNotebookStore } from '@/stores/notebook'
import MonacoEditor from '@/components/MonacoEditor.vue'
import OutputDisplay from '@/components/OutputDisplay.vue'

const notebookStore = useNotebookStore()
const activeCell = ref('')
const isRunning = ref(false)

// 编辑器配置
const editorOptions = {
  minimap: { enabled: false },
  lineNumbers: 'on',
  roundedSelection: false,
  scrollBeyondLastLine: false,
  readOnly: false,
  theme: 'vs-dark'
}

// 运行代码
const runCell = async () => {
  if (!activeCell.value) return
  
  isRunning.value = true
  try {
    await notebookStore.executeCell(activeCell.value)
  } finally {
    isRunning.value = false
  }
}
</script>
```

#### 2.3 实现状态管理（0.5天）

状态管理的实现需要关注以下方面：

1. 数据结构设计：
   - 定义清晰的状态类型
   - 设计合理的状态树结构
   - 实现状态的规范化
   - 优化状态的访问效率

2. 状态操作接口：
   - 提供统一的状态修改方法
   - 实现状态变更的追踪
   - 支持状态的回滚和重做
   - 处理状态冲突

3. 持久化管理：
   - 实现状态的本地存储
   - 提供状态的导入导出
   - 处理状态的版本控制
   - 实现状态的自动保存

##### Notebook Store
```typescript
// stores/notebook.ts
import { defineStore } from 'pinia'
import type { NotebookState, Cell } from '@/types'

export const useNotebookStore = defineStore('notebook', {
  state: () => ({
    notebooks: [] as NotebookState[],
    openedNotebooks: [] as string[],
    activeNotebookId: null as string | null,
    cellStates: {} as Record<string, Cell[]>,
    executionStatus: {} as Record<string, string>,
  }),
  
  getters: {
    currentNotebook(): NotebookState | null {
      if (!this.activeNotebookId) return null
      return this.notebooks.find(
        n => n.id === this.activeNotebookId
      ) || null
    },
    
    currentCells(): Cell[] {
      if (!this.activeNotebookId) return []
      return this.cellStates[this.activeNotebookId] || []
    },
  },
  
  actions: {
    async createNotebook() {
      const response = await api.post('/notebooks')
      const notebook = response.data
      
      this.notebooks.push({
        id: notebook.id,
        name: `Notebook ${this.notebooks.length + 1}`,
        status: 'idle',
        lastModified: new Date(),
      })
      
      this.openedNotebooks.push(notebook.id)
      this.activeNotebookId = notebook.id
      this.cellStates[notebook.id] = []
    },
    
    async executeCell(cellId: string) {
      if (!this.activeNotebookId) return
      
      const cell = this.currentCells.find(c => c.id === cellId)
      if (!cell) return
      
      try {
        cell.status = 'running'
        const response = await api.post(
          `/notebooks/${this.activeNotebookId}/execute`,
          { code: cell.content }
        )
        
        cell.output = response.data.output
        cell.status = 'idle'
      } catch (error) {
        cell.status = 'error'
        cell.output = error.message
      }
    },
  },
})
```

#### 2.4 实现WebSocket通信（0.5天）

WebSocket通信的实现需要考虑：

1. 连接管理：
   - 实现连接的建立和维护
   - 处理连接的断开和重连
   - 管理多个笔记本的连接
   - 实现心跳检测机制

2. 消息处理：
   - 定义标准的消息格式
   - 实现消息的序列化和反序列化
   - 处理消息的优先级
   - 提供消息的重试机制

3. 错误处理：
   - 处理网络异常
   - 实现消息的确认机制
   - 提供错误恢复策略
   - 记录通信日志

##### WebSocket客户端
```typescript
// services/websocket.ts
export class NotebookWebSocket {
  private ws: WebSocket
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectTimeout = 1000
  
  constructor(notebookId: string) {
    this.ws = this.connect(notebookId)
    this.setupEventHandlers()
  }
  
  private connect(notebookId: string): WebSocket {
    const ws = new WebSocket(
      `ws://${window.location.host}/ws/notebooks/${notebookId}`
    )
    return ws
  }
  
  private setupEventHandlers() {
    this.ws.onmessage = this.handleMessage.bind(this)
    this.ws.onclose = this.handleClose.bind(this)
    this.ws.onerror = this.handleError.bind(this)
  }
  
  private handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data)
    switch (data.type) {
      case 'notebook_status':
        store.updateNotebookStatus(data)
        break
      case 'execution_status':
        store.updateExecutionStatus(data)
        break
    }
  }
  
  private handleClose() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++
        this.ws = this.connect(this.notebookId)
      }, this.reconnectTimeout * this.reconnectAttempts)
    }
  }
}
```

### 第三阶段：功能完善（预计2天）

#### 3.1 实现标签页拖拽排序（0.5天）

拖拽排序功能的实现需要考虑：

1. 交互体验：
   - 实现平滑的拖拽动画
   - 提供视觉反馈
   - 优化拖拽性能
   - 处理边界情况

2. 数据同步：
   - 维护标签页顺序
   - 处理拖拽过程中的状态更新
   - 实现撤销/重做功能
   - 保存用户的排序偏好

3. 兼容性处理：
   - 支持不同设备的触控操作
   - 处理不同浏览器的兼容性
   - 提供键盘操作支持
   - 适配不同屏幕尺寸

##### 拖拽排序实现
```typescript
// components/DraggableTabs.vue
import { Sortable } from 'sortablejs'

export default defineComponent({
  setup() {
    const tabsRef = ref<HTMLElement | null>(null)
    
    onMounted(() => {
      if (!tabsRef.value) return
      
      new Sortable(tabsRef.value.querySelector('.el-tabs__nav'), {
        animation: 150,
        ghostClass: 'ghost',
        onEnd: ({ oldIndex, newIndex }) => {
          if (oldIndex === newIndex) return
          notebookStore.reorderTabs(oldIndex, newIndex)
        }
      })
    })
    
    return { tabsRef }
  }
})

// stores/notebook.ts
export const useNotebookStore = defineStore('notebook', {
  actions: {
    reorderTabs(oldIndex: number, newIndex: number) {
      const tabs = [...this.openedNotebooks]
      const [movedTab] = tabs.splice(oldIndex, 1)
      tabs.splice(newIndex, 0, movedTab)
      this.openedNotebooks = tabs
    }
  }
})
```

#### 3.2 实现标签页右键菜单（0.5天）

右键菜单功能的实现需要关注：

1. 菜单设计：
   - 提供常用操作选项
   - 实现快捷键绑定
   - 支持子菜单功能
   - 优化菜单布局

2. 交互处理：
   - 处理点击和悬停事件
   - 实现菜单的定位显示
   - 提供键盘导航支持
   - 处理菜单外点击关闭

3. 功能实现：
   - 执行菜单命令
   - 处理命令的权限控制
   - 提供操作的反馈
   - 支持批量操作

##### 右键菜单组件
```vue
<!-- components/NotebookContextMenu.vue -->
<template>
  <div 
    v-show="visible"
    class="context-menu"
    :style="position"
  >
    <div 
      v-for="item in menuItems"
      :key="item.command"
      class="menu-item"
      @click="handleCommand(item.command)"
    >
      <el-icon><component :is="item.icon" /></el-icon>
      <span>{{ item.label }}</span>
      <span v-if="item.shortcut" class="shortcut">
        {{ item.shortcut }}
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
const menuItems = [
  {
    label: '关闭',
    command: 'close',
    icon: 'Close',
    shortcut: 'Ctrl+W'
  },
  {
    label: '关闭其他',
    command: 'closeOthers',
    icon: 'CircleClose'
  },
  {
    label: '关闭右侧',
    command: 'closeRight',
    icon: 'ArrowRight'
  },
  {
    label: '关闭所有',
    command: 'closeAll',
    icon: 'Remove'
  }
]

// 快捷键支持
const setupShortcuts = () => {
  const shortcuts = {
    'ctrl+w': () => handleCommand('close'),
    'ctrl+shift+w': () => handleCommand('closeAll')
  }
  
  useEventListener(window, 'keydown', (e: KeyboardEvent) => {
    const key = `${e.ctrlKey ? 'ctrl+' : ''}${e.shiftKey ? 'shift+' : ''}${e.key.toLowerCase()}`
    shortcuts[key]?.()
  })
}
</script>
```

#### 3.3 实现笔记本状态同步（0.5天）

状态同步的实现需要考虑：

1. 实时性要求：
   - 确保状态更新的及时性
   - 处理网络延迟问题
   - 实现状态的批量更新
   - 优化更新频率

2. 数据一致性：
   - 处理并发更新冲突
   - 实现状态的版本控制
   - 提供数据校验机制
   - 处理同步失败的恢复

3. 性能优化：
   - 减少不必要的状态更新
   - 实现增量更新机制
   - 优化数据传输格式
   - 实现状态缓存

##### WebSocket服务器端实现
```python
# services/websocket_manager.py
class NotebookWebSocketManager:
    def __init__(self):
        self._connections: Dict[str, Set[WebSocket]] = {}
        self._lock = asyncio.Lock()
    
    async def connect(self, notebook_id: str, websocket: WebSocket):
        async with self._lock:
            if notebook_id not in self._connections:
                self._connections[notebook_id] = set()
            self._connections[notebook_id].add(websocket)
    
    async def disconnect(self, notebook_id: str, websocket: WebSocket):
        async with self._lock:
            if notebook_id in self._connections:
                self._connections[notebook_id].remove(websocket)
    
    async def broadcast_status(
        self, 
        notebook_id: str, 
        status: Dict[str, Any]
    ):
        if notebook_id not in self._connections:
            return
            
        message = {
            "type": "notebook_status",
            "notebook_id": notebook_id,
            "status": status,
            "timestamp": datetime.now().isoformat()
        }
        
        for connection in self._connections[notebook_id]:
            try:
                await connection.send_json(message)
            except WebSocketDisconnect:
                await self.disconnect(notebook_id, connection)
```

##### 状态同步实现
```python
# services/notebook_status.py
class NotebookStatusTracker:
    def __init__(self, websocket_manager: NotebookWebSocketManager):
        self.websocket_manager = websocket_manager
        self._status_cache = {}
    
    async def update_status(
        self, 
        notebook_id: str, 
        status: str, 
        details: Dict[str, Any] = None
    ):
        status_data = {
            "status": status,
            "details": details or {},
            "timestamp": datetime.now().isoformat()
        }
        
        self._status_cache[notebook_id] = status_data
        await self.websocket_manager.broadcast_status(
            notebook_id, 
            status_data
        )
```

#### 3.4 实现资源管理（0.5天）

资源管理的实现需要关注：

1. 监控机制：
   - 实时监控系统资源
   - 收集性能指标
   - 设置告警阈值
   - 生成资源使用报告

2. 限制策略：
   - 实现资源配额管理
   - 处理资源超限情况
   - 提供资源释放机制
   - 优化资源分配

3. 自动化管理：
   - 实现自动清理机制
   - 提供资源回收策略
   - 处理异常情况
   - 维护系统稳定性

##### 资源监控实现
```python
# services/resource_monitor.py
import psutil
import asyncio
from typing import Dict, Any

class ResourceMonitor:
    def __init__(self):
        self._notebook_processes: Dict[str, psutil.Process] = {}
        self._monitoring = False
    
    async def start_monitoring(self):
        self._monitoring = True
        while self._monitoring:
            await self._check_resources()
            await asyncio.sleep(5)  # 每5秒检查一次
    
    async def _check_resources(self):
        for notebook_id, process in self._notebook_processes.items():
            try:
                # 获取进程资源使用情况
                cpu_percent = process.cpu_percent()
                memory_info = process.memory_info()
                
                if cpu_percent > 90 or memory_info.rss > 1e9:  # 1GB
                    await self._handle_resource_limit_exceeded(
                        notebook_id,
                        {
                            "cpu_percent": cpu_percent,
                            "memory_usage": memory_info.rss
                        }
                    )
            except psutil.NoSuchProcess:
                # 进程已结束，清理记录
                del self._notebook_processes[notebook_id]
```

### 第四阶段：优化和测试（预计2天）

#### 4.1 性能优化（0.5天）

性能优化需要关注以下方面：

1. 前端优化：
   - 实现虚拟滚动
   - 优化渲染性能
   - 减少不必要的重渲染
   - 实现懒加载机制

2. 后端优化：
   - 优化数据库查询
   - 实现缓存机制
   - 优化代码执行效率
   - 减少资源占用

3. 网络优化：
   - 减少数据传输量
   - 优化请求频率
   - 实现数据压缩
   - 优化WebSocket通信

##### 虚拟滚动实现
```typescript
// components/VirtualScroller.vue
<template>
  <div 
    class="virtual-scroller"
    :style="{ height: totalHeight + 'px' }"
    @scroll="handleScroll"
  >
    <div
      class="virtual-scroller-content"
      :style="{ transform: `translateY(${offsetY}px)` }"
    >
      <template v-for="item in visibleItems" :key="item.id">
        <slot name="item" :item="item" />
      </template>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  items: any[]
  itemHeight: number
  buffer?: number
}>()

const visibleItems = computed(() => {
  const start = Math.max(0, startIndex.value - (props.buffer || 5))
  const end = Math.min(
    props.items.length,
    endIndex.value + (props.buffer || 5)
  )
  return props.items.slice(start, end)
})
</script>
```

##### 状态更新优化
```typescript
// utils/debounce.ts
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout
  
  return function (...args: Parameters<T>) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => fn.apply(this, args), delay)
  }
}

// stores/notebook.ts
export const useNotebookStore = defineStore('notebook', {
  actions: {
    updateStatus: debounce(function (status: NotebookStatus) {
      this.status = status
    }, 100)
  }
})
```

#### 4.2 用户体验优化（0.5天）

用户体验优化需要考虑：

1. 交互设计：
   - 提供清晰的状态反馈
   - 优化加载体验
   - 实现平滑的动画效果
   - 提供操作提示

2. 错误处理：
   - 提供友好的错误提示
   - 实现错误恢复机制
   - 提供问题解决建议
   - 优化异常流程

3. 可访问性：
   - 支持键盘操作
   - 提供屏幕阅读支持
   - 优化色彩对比度
   - 实现响应式设计

##### 加载状态和错误提示
```vue
<!-- components/LoadingOverlay.vue -->
<template>
  <div 
    v-if="loading"
    class="loading-overlay"
  >
    <el-spinner />
    <div class="loading-text">{{ message }}</div>
  </div>
</template>

<!-- components/ErrorNotification.vue -->
<template>
  <el-alert
    v-if="error"
    :title="error.title"
    :description="error.message"
    type="error"
    show-icon
    closable
  >
    <template #action>
      <el-button 
        type="primary" 
        size="small"
        @click="handleRetry"
      >
        重试
      </el-button>
    </template>
  </el-alert>
</template>
```

#### 4.3 单元测试（0.5天）

测试实现需要关注：

1. 测试覆盖：
   - 编写完整的单元测试
   - 实现集成测试
   - 进行性能测试
   - 执行兼容性测试

2. 测试框架：
   - 使用合适的测试工具
   - 实现测试自动化
   - 提供测试报告
   - 集成持续集成系统

3. 测试维护：
   - 保持测试代码的可维护性
   - 更新测试用例
   - 处理测试失败
   - 优化测试效率

##### 后端测试
```python
# tests/test_notebook_manager.py
import pytest
from app.services.notebook import NotebookManager

@pytest.mark.asyncio
async def test_notebook_creation():
    manager = NotebookManager()
    notebook_id = "test-notebook"
    
    notebook = await manager.create_notebook(notebook_id)
    assert notebook.notebook_id == notebook_id
    assert notebook.status == "idle"
    
    with pytest.raises(ValueError):
        await manager.create_notebook(notebook_id)

# tests/test_code_execution.py
@pytest.mark.asyncio
async def test_code_execution():
    executor = CodeExecutor()
    code = "print('hello')"
    
    result = await executor.execute_code(
        code,
        globals(),
        locals()
    )
    
    assert result.status == "success"
    assert result.output.strip() == "hello"
```

#### 4.4 文档和部署（0.5天）

文档和部署需要考虑：

1. 文档编写：
   - 提供详细的API文档
   - 编写使用说明
   - 包含示例代码
   - 更新变更日志

2. 部署流程：
   - 制定部署策略
   - 准备部署脚本
   - 配置环境变量
   - 实现自动化部署

3. 维护计划：
   - 制定备份策略
   - 规划升级流程
   - 准备回滚方案
   - 建立监控机制

##### API文档
```markdown
# 笔记本API文档

## 创建笔记本
POST /api/notebooks

创建一个新的笔记本实例。

### 请求参数
无

### 响应
```json
{
    "notebook_id": "uuid",
    "status": "created"
}
```

### 错误
- 400: 达到最大笔记本数量限制
- 500: 服务器内部错误
```

##### 部署脚本
```bash
#!/bin/bash
# deploy.sh

# 1. 构建前端
echo "Building frontend..."
cd frontend
npm install
npm run build

# 2. 构建后端
echo "Building backend..."
cd ../backend
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# 3. 运行数据库迁移
echo "Running migrations..."
alembic upgrade head

# 4. 重启服务
echo "Restarting services..."
supervisorctl restart notebook_server
supervisorctl restart notebook_worker
```

## 接口设计

### 后端API

#### 笔记本管理
```python
# 创建笔记本
POST /api/notebooks
Response: {
    "notebook_id": "uuid",
    "status": "created"
}

# 获取笔记本列表
GET /api/notebooks
Response: {
    "notebooks": [
        {
            "id": "uuid",
            "name": "Notebook 1",
            "status": "idle",
            "last_modified": "timestamp"
        }
    ]
}

# 删除笔记本
DELETE /api/notebooks/{notebook_id}
Response: {
    "status": "success"
}

# 执行代码
POST /api/notebooks/{notebook_id}/execute
Request: {
    "code": "print('Hello')"
}
Response: {
    "output": "Hello",
    "status": "success"
}
```

### WebSocket事件

```typescript
// 笔记本状态更新
{
    "type": "notebook_status",
    "notebook_id": "uuid",
    "status": "running|idle|error",
    "timestamp": "iso_timestamp"
}

// 执行状态更新
{
    "type": "execution_status",
    "notebook_id": "uuid",
    "cell_id": "uuid",
    "status": "running|complete|error",
    "output": "string",
    "timestamp": "iso_timestamp"
}
```

## 数据结构

### 笔记本状态
```typescript
interface NotebookState {
    id: string;
    name: string;
    status: 'idle' | 'running' | 'error';
    lastModified: Date;
    cells: Cell[];
    variables: Record<string, any>;
    dataframes: Record<string, DataFrameInfo>;
}

interface Cell {
    id: string;
    type: 'code' | 'markdown';
    content: string;
    output?: string;
    status: 'idle' | 'running' | 'error';
    executionCount?: number;
}
```

## 注意事项

1. 内存管理
   - 及时清理未使用的笔记本实例
   - 监控内存使用情况
   - 实现资源使用限制

2. 并发控制
   - 限制最大并发笔记本数量
   - 实现笔记本执行队列
   - 处理执行超时情况

3. 错误处理
   - 完善错误捕获机制
   - 提供详细的错误信息
   - 实现错误恢复机制

4. 性能优化
   - 实现必要的缓存机制
   - 优化状态更新频率
   - 控制WebSocket消息大小

## 后续优化

1. 功能扩展
   - 笔记本导入/导出
   - 代码自动补全
   - 变量查看器
   - 图表预览

2. 性能提升
   - 引入Redis缓存
   - 优化数据传输
   - 实现延迟加载

3. 用户体验
   - 快捷键支持
   - 主题定制
   - 移动端适配
   - 协作编辑 
```

## 渐进式开发实现方案

为确保系统在开发过程中始终保持可用状态，我们需要采用渐进式开发策略，将整个开发过程分解为多个独立的、可验证的小步骤。每个步骤都需要保证：

1. 系统功能的完整性
2. 已有功能的正常运行
3. 新旧版本的兼容性
4. 可独立测试和回滚

### 阶段一：后端改造（5天）

#### 步骤1.1：笔记本管理器改造（1天）

1. 创建新的笔记本管理器，但保留原有实现：
```python
class LegacyNotebookManager:
    """保留原有的笔记本管理器实现"""
    pass

class NewNotebookManager:
    """新的笔记本管理器实现"""
    def __init__(self):
        self._notebooks: Dict[str, NotebookInstance] = {}
        self._lock = asyncio.Lock()
        
    async def create_notebook(self, notebook_id: str) -> NotebookInstance:
        # 新的实现
        pass
        
    async def get_notebook(self, notebook_id: str) -> NotebookInstance:
        # 新的实现
        pass

class NotebookManagerFactory:
    """工厂类用于管理新旧版本切换"""
    @staticmethod
    def create_manager(use_new_version: bool = False) -> Union[LegacyNotebookManager, NewNotebookManager]:
        if use_new_version:
            return NewNotebookManager()
        return LegacyNotebookManager()
```

2. 使用特性开关控制版本：
```python
# config.py
class FeatureFlags:
    USE_NEW_NOTEBOOK_MANAGER = False
    USE_MULTI_NOTEBOOK = False
    USE_NEW_WEBSOCKET = False

# main.py
notebook_manager = NotebookManagerFactory.create_manager(
    FeatureFlags.USE_NEW_NOTEBOOK_MANAGER
)
```

#### 步骤1.2：代码执行环境隔离（1天）

1. 实现新的执行上下文，同时保持原有执行方式：
```python
class CodeExecutionContext:
    """新的代码执行上下文"""
    def __init__(self, notebook_id: str):
        self.notebook_id = notebook_id
        self.globals_dict = self._initialize_globals()
        self._setup_isolation()
    
    def _setup_isolation(self):
        # 设置环境隔离
        pass
        
    async def execute(self, code: str) -> ExecutionResult:
        if FeatureFlags.USE_MULTI_NOTEBOOK:
            return await self._execute_isolated(code)
        return await self._execute_legacy(code)
```

2. 实现数据隔离的兼容层：
```python
class DataFrameRegistry:
    """DataFrame注册表"""
    def __init__(self):
        self._dataframes: Dict[str, Dict[str, pd.DataFrame]] = {}
        self._legacy_dataframes: Dict[str, pd.DataFrame] = {}
        
    def get_dataframe(self, name: str, notebook_id: str = None) -> Optional[pd.DataFrame]:
        if FeatureFlags.USE_MULTI_NOTEBOOK and notebook_id:
            return self._dataframes.get(notebook_id, {}).get(name)
        return self._legacy_dataframes.get(name)
```

#### 步骤1.3：API路由适配（1天）

1. 创建新的API路由，保留原有路由：
```python
# routes/notebook_routes.py
@router.post("/notebooks")
async def create_notebook(
    request: Request,
    use_new_version: bool = Query(False)
):
    if use_new_version:
        return await create_notebook_v2(request)
    return await create_notebook_v1(request)

@router.post("/notebooks/{notebook_id}/execute")
async def execute_code(
    notebook_id: str,
    code: str,
    use_new_version: bool = Query(False)
):
    if use_new_version:
        return await execute_code_v2(notebook_id, code)
    return await execute_code_v1(code)
```

2. 实现版本兼容的响应格式：
```python
class NotebookResponse(BaseModel):
    """统一的响应格式"""
    version: str = "1.0"
    data: Dict[str, Any]
    legacy_format: Optional[Dict[str, Any]]
    
    def to_response(self) -> Dict[str, Any]:
        if FeatureFlags.USE_MULTI_NOTEBOOK:
            return self.data
        return self.legacy_format or self.data
```

#### 步骤1.4：WebSocket改造（1天）

1. 实现新的WebSocket管理器：
```python
class WebSocketManager:
    """WebSocket连接管理器"""
    def __init__(self):
        self._legacy_connections: Set[WebSocket] = set()
        self._notebook_connections: Dict[str, Set[WebSocket]] = {}
        
    async def broadcast(self, message: Dict[str, Any], notebook_id: str = None):
        if FeatureFlags.USE_NEW_WEBSOCKET:
            await self._broadcast_to_notebook(message, notebook_id)
        else:
            await self._broadcast_legacy(message)
```

2. 实现消息格式兼容：
```python
class WebSocketMessage:
    """WebSocket消息封装"""
    def __init__(self, data: Dict[str, Any]):
        self.data = data
        
    def to_legacy_format(self) -> Dict[str, Any]:
        """转换为旧版本格式"""
        pass
        
    def to_new_format(self) -> Dict[str, Any]:
        """转换为新版本格式"""
        pass
        
    def serialize(self) -> str:
        if FeatureFlags.USE_NEW_WEBSOCKET:
            return json.dumps(self.to_new_format())
        return json.dumps(self.to_legacy_format())
```

#### 步骤1.5：数据迁移支持（1天）

1. 实现数据迁移工具：
```python
class NotebookMigrationTool:
    """笔记本数据迁移工具"""
    @staticmethod
    async def migrate_notebook(notebook_id: str):
        # 获取旧版本数据
        old_data = await get_legacy_notebook_data(notebook_id)
        
        # 转换为新格式
        new_data = convert_to_new_format(old_data)
        
        # 保存新版本数据
        await save_new_notebook_data(notebook_id, new_data)
        
    @staticmethod
    async def rollback_migration(notebook_id: str):
        # 实现回滚逻辑
        pass
```

2. 实现自动迁移检测：
```python
class NotebookVersionDetector:
    """笔记本版本检测器"""
    @staticmethod
    async def check_version(notebook_id: str) -> str:
        # 检测笔记本版本
        pass
        
    @staticmethod
    async def needs_migration(notebook_id: str) -> bool:
        # 检查是否需要迁移
        pass
```

### 阶段二：前端改造（5天）

#### 步骤2.1：状态管理改造（1天）

1. 实现新的状态管理，保持向后兼容：
```typescript
// stores/notebook.ts
export const useNotebookStore = defineStore('notebook', {
  state: () => ({
    // 兼容旧版本的状态
    legacyState: {
      currentNotebook: null,
      cells: [],
      outputs: {}
    },
    // 新版本的状态
    notebooks: [],
    activeNotebookId: null,
    cellStates: {},
  }),
  
  getters: {
    currentNotebook(): NotebookState | null {
      if (FeatureFlags.USE_MULTI_NOTEBOOK) {
        return this.notebooks.find(n => n.id === this.activeNotebookId)
      }
      return this.legacyState.currentNotebook
    }
  }
})
```

2. 实现状态迁移助手：
```typescript
// utils/state-migration.ts
export class StateMigrationHelper {
  static migrateToNewFormat(legacyState: any): NewState {
    // 实现状态转换逻辑
  }
  
  static migrateToLegacyFormat(newState: NewState): any {
    // 实现反向转换逻辑
  }
}
```

#### 步骤2.2：UI组件改造（1天）

1. 实现渐进式UI更新：
```vue
<!-- components/NotebookEditor.vue -->
<template>
  <div class="notebook-editor">
    <!-- 使用v-if控制新旧版本切换 -->
    <template v-if="useNewVersion">
      <notebook-tabs />
      <new-editor-content />
    </template>
    <template v-else>
      <legacy-editor-content />
    </template>
  </div>
</template>

<script setup lang="ts">
const useNewVersion = computed(() => {
  return FeatureFlags.USE_MULTI_NOTEBOOK
})
</script>
```

2. 实现组件包装器：
```typescript
// utils/component-wrapper.ts
export function withVersionControl(component: Component): Component {
  return {
    setup(props, context) {
      const useNewVersion = computed(() => FeatureFlags.USE_MULTI_NOTEBOOK)
      
      return () => h(useNewVersion.value ? NewComponent : LegacyComponent, props)
    }
  }
}
```

#### 步骤2.3：API调用适配（1天）

1. 实现API客户端适配器：
```typescript
// api/notebook-client.ts
export class NotebookApiClient {
  async createNotebook() {
    if (FeatureFlags.USE_MULTI_NOTEBOOK) {
      return await this.createNotebookV2()
    }
    return await this.createNotebookV1()
  }
  
  async executeCode(notebookId: string, code: string) {
    if (FeatureFlags.USE_MULTI_NOTEBOOK) {
      return await this.executeCodeV2(notebookId, code)
    }
    return await this.executeCodeV1(code)
  }
}
```

2. 实现响应数据转换：
```typescript
// utils/response-transformer.ts
export class ResponseTransformer {
  static transformExecutionResult(response: any): ExecutionResult {
    if (FeatureFlags.USE_MULTI_NOTEBOOK) {
      return this.transformNewFormat(response)
    }
    return this.transformLegacyFormat(response)
  }
}
```

#### 步骤2.4：WebSocket客户端改造（1天）

1. 实现WebSocket连接管理：
```typescript
// services/websocket.ts
export class NotebookWebSocketClient {
  private ws: WebSocket | null = null
  
  connect(notebookId?: string) {
    const url = this.getWebSocketUrl(notebookId)
    this.ws = new WebSocket(url)
    this.setupEventHandlers()
  }
  
  private getWebSocketUrl(notebookId?: string): string {
    if (FeatureFlags.USE_MULTI_NOTEBOOK && notebookId) {
      return `/ws/notebooks/${notebookId}`
    }
    return '/ws/notebook'
  }
}
```

2. 实现消息处理适配：
```typescript
// services/message-handler.ts
export class WebSocketMessageHandler {
  handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data)
    
    if (FeatureFlags.USE_MULTI_NOTEBOOK) {
      this.handleNewFormatMessage(data)
    } else {
      this.handleLegacyMessage(data)
    }
  }
}
```

#### 步骤2.5：测试和调试支持（1天）

1. 实现特性开关控制面板：
```vue
<!-- components/FeatureFlags.vue -->
<template>
  <div class="feature-flags-panel">
    <el-switch
      v-model="useMultiNotebook"
      active-text="启用多笔记本支持"
    />
    <el-switch
      v-model="useNewWebSocket"
      active-text="启用新版WebSocket"
    />
  </div>
</template>
```

2. 实现调试工具：
```typescript
// utils/debug-tools.ts
export class DebugTools {
  static async validateState() {
    // 验证状态一致性
  }
  
  static async compareOutputs() {
    // 比较新旧版本输出
  }
}
```

### 发布策略

1. 灰度发布
```typescript
// config/feature-flags.ts
export const FeatureFlags = {
  // 基于用户ID启用功能
  shouldEnableMultiNotebook(userId: string): boolean {
    return WHITELISTED_USERS.includes(userId)
  },
  
  // 基于比例启用功能
  shouldEnableByPercentage(percentage: number): boolean {
    return Math.random() < percentage / 100
  }
}
```

2. 回滚机制
```typescript
// utils/rollback.ts
export class RollbackManager {
  static async rollback(version: string) {
    // 禁用所有新特性
    await this.disableFeatureFlags()
    
    // 转换数据格式
    await this.migrateDataBack()
    
    // 重置状态
    await this.resetState()
  }
}
```

3. 监控指标
```typescript
// utils/metrics.ts
export class FeatureMetrics {
  static trackFeatureUsage(feature: string) {
    // 记录功能使用情况
  }
  
  static trackErrors(feature: string, error: Error) {
    // 记录错误情况
  }
  
  static generateReport(): FeatureReport {
    // 生成功能使用报告
  }
}
```

### 测试策略

1. 单元测试
```python
# tests/test_compatibility.py
class TestCompatibility:
    async def test_notebook_creation_compatibility(self):
        # 测试新旧版本笔记本创建
        old_notebook = await create_notebook_v1()
        new_notebook = await create_notebook_v2()
        
        assert old_notebook['status'] == 'success'
        assert new_notebook['status'] == 'success'
    
    async def test_code_execution_compatibility(self):
        # 测试代码执行兼容性
        old_result = await execute_code_v1("print('test')")
        new_result = await execute_code_v2("test_notebook", "print('test')")
        
        assert old_result['output'] == new_result['output']
```

2. 集成测试
```python
# tests/test_integration.py
class TestIntegration:
    async def test_mixed_version_operation(self):
        # 测试新旧版本混合操作
        notebook1 = await create_notebook_v1()
        notebook2 = await create_notebook_v2()
        
        # 执行代码
        result1 = await execute_code_v1("a = 1")
        result2 = await execute_code_v2(notebook2['id'], "b = 2")
        
        # 验证结果
        assert result1['status'] == 'success'
        assert result2['status'] == 'success'
```

3. 性能测试
```python
# tests/test_performance.py
class TestPerformance:
    async def test_version_performance_comparison(self):
        # 比较新旧版本性能
        start_time = time.time()
        await execute_code_v1("import numpy as np")
        v1_time = time.time() - start_time
        
        start_time = time.time()
        await execute_code_v2("test_notebook", "import numpy as np")
        v2_time = time.time() - start_time
        
        # 验证性能没有显著下降
        assert v2_time <= v1_time * 1.1
```

// ... existing code ... 